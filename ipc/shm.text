//共享内存 -- 进程间通信
//  1.在物理内存上开辟一块内存空间
//  2.将这块物理内存映射到进程地虚拟地址空间
//  3.进程就可以通过虚拟地址直接访问这块物理内存
//  多个进程要是映射同一块物理内存，就可以通过这块内存实现数据共享
//为什么是最快的？
//  共享内存是直接通过虚拟地址访问物理内存，而其他方式都是内核中的缓冲区，
//  较于其他方式，少了用户态、内核态的两次数据拷贝

//流程：
//  1.创建共享内存（开辟物理内存空间 -- 具有标识符）
//    int shmget(key_t key, int size, int flag)
//    key：共享内存的标识符，多个进程通过相同的标识符可以打开同一块共享内存
//    size：共享内存大小 -- 单位：页
//    flag：IPC_CREAT | IPC_EXCL | 权限
//    返回值：成功返回一个操作句柄；失败返回-1
//  2.将共享内存映射到各个进程的虚拟地址空间
//    void* shmat(int shmid, void* addr, flag)
//    shmid：共享内存操作句柄；
//    addr：映射到虚拟地址空间的首地址，通常置NULL；
//    flag：通常置0-可读可写 SHM_RDONLY-只读，该flag取决于上述创建时的权限
//    返回值：成功返回映射的虚拟空间的首地址，失败返回-1
//  3.直接通过虚拟地址进行内存操作
//    
//  4.解除映射关系
//    int shmdt(void* shmstart)
//    shmstart：映射到虚拟地址空间的首地址
//    返回值：成功返回0，失败返回-1
//  5.删除共享内存
//    int shmctl(int shmid, int cmd, struct shmid_ds* buf);
//    shmid：共享内存操作句柄
//    cmd：具体对共享内存要进行的操作 -- IPC_RMID-删除共享内存
//    返回值：成功0；失败-1；

ipcs  查看进程间通信资源
  -m    查看共享内存
  -q    查看消息队列
  -s    查看信号量
ipcrm 删除进程间通信资源
  删除共享内存时，并不会立即删除，因为有可能会造成正在访问的进程崩溃，
    而是将key值修改为0，表示这块共享内存将不会再接收映射连接，当这块共享内存映射连接数为0的时候，则自动被释放

特性：
  1.最快的进程间通信方式
  2.生命周期随内核
注意事项：
  共享内存的操作时不安全的（并不会自动具备同步与互斥关系，需要操作用户进行控制）

消息队列：
  本质上就是内核中的一个优先级队列，多个进程通过向同一个队列中添加节点和获取节点实现通信
  传输一个有类型（优先级）的数据块
特性：
  1.自带同步与互斥
  2.生周期随内核
  3.数据传输自带优先级
  


